## 1. 🤨 CSR(Clinet Side Rendering) 이란?

- 최초 한 번 서버에서 전체 페이지를 로딩하여 보여주고, 이후에는 사용자의 요청이 올때마다 리소스를 서버에서 제공한 후 클라이언트가 해석하고 랜더링 하는 방식이다.

- 첫 방문 시 필요한 모든 리소스들을 다운 받기 때문에, 사용자에게 첫 화면을 느리게 보여줄 수도 있다.
- TTV와 TTI가 같다.

```
TTV : Time To View, 클라이언트에서 페이지의 내용을 볼 수 있을 때까지의 시간을 의미한다.

TTI : Time To Interact, 클라이언트에서 페이지의 내용을 동작할 수 있을 때까지의 시간을 의미한다.

CSR은 모든 리소스를 다운 받기 때문에 보여지는 시간과 동작하는 시간이 같다.
```

- SPA에서 사용되는 페이지 랜더링 기술이다.

```
 SPA란?
 - single-page application의 약자로 하나의 페이지로 구성된 웹 어플리케이션
 - 리로딩 없이 필요한 부분만 서버에서 받아와 화면을 갱신
 - 필요한 부분만 갱신하기 때문에 네이티브 앱에 가까운 자연스러운 페이지 이동과 사용자 경험을 제공 가능
 - React, Vue, Angular가 채택한 방식
```

## 😊 CSR의 장점

- 페이지를 이동할 때 깜박거림이 없다. 필요한 부분만 클라이언트에게 요청하기 때문이다.

- 서버측의 렌더링 부담을 줄여준다. 서버 리소스를 상대적으로 덜 낭비하기 때문이다.

- 다른 페이지로 이동할 때 모든 파일을 다시 요청할 필요가 없어 첫 로딩 이후 로딩 시간은 SSR에 비해 빠르다.

## 😤 CSR의 단점

- CSR은 서버에서 클라이언트로 전송되는 초기 HTML에는 동적으로 생성되는 콘텐츠가 포함되지 않고, 검색 엔진 크롤러가 페이지를 수집할 때 동적으로 생성된 콘텐츠를 인식하지 못하고 검색 결과에서 노출되는 확률도 떨어진다.

- 위에서 말한 것처럼, 모든 리소스를 다운 받기 때문에 첫 화면을 느리게 보여줄 수 있다.

<br/>

## 2. 🤨 SSR(Server Side Rendering)이란?

- 서버에서 렌더링된 상태로 사용자에게 전해지는 것을 말한다.

- 렌더링된 HTML 파일이 먼저 사용자에게 다운 받아진 후, 실행에 필요한 JS 코드를 다운로드 받게 되는 형식.

- 다운 받은 HTML 파일을 먼저 보여주기 때문에 사용자는 첫 화면을 CSR보다 빨리 볼 수 있다.

- TTV와 TTI의 시간이 다르다. 사용자 화면에 보여주는 TTV는 짧고, 동작이 실행되는 TTI 시간은 느리다.

- MPA를 구현하는 데 쓰이는 렌더링 방식이다.

```
- Multi Page Application의 약자로 새로운 페이지를 요청할 때마다 서버에서 렌더링된 정적 리소스가 다운되는 전통적인 웹페이지 구성 방식

- 페이지를 이동하거나 새로고침하면 전체 페이지를 다시 렌더링한다.
```

## 😊 SSR의 장점

- 컨텐츠가 들어있는 상태로 html 파일을 받기 때문에 이 내용을 토대로 검색 키워드에 맞게 사용자에게 검색 결화 화면을 보여준다. => 검색 엔진 최적화

- 사용자가 볼 수 있는 화면을 바로 html 파일로 받기 때문에 첫 화면 랜더링 속도가 CSR보다 비교적 빠르다.

## 😤 SSR의 단점

- 클릭했을 때 요청마다 새로고침 되기 때문에 깜빡임이 생긴다.

- 초기 랜더링은 빠르지만, 중복되는 내용도 다시 렌더링 받기 때문에 이후 랜더링 속도는 CSR보다 느린 편에 속한다.

- TTV와 TTI의 간극 동안 유저 입장에서 불쾌한 경험을 선사할 수 있다.

## 3.📍 CSR과 SSR의 차이

1. 웹페이지 로딩 시간

- 첫 페이지 로딩 시간은 CSR은 HTML, CSS와 모든 스크립트를 한 번에 불러오고, SSR은 필요한 부분의 HTML과 스크립트만 불러오기 때문에 SSR이 더 빠르다.
- 첫 페이지를 제외한 나머지 로딩 시간은 CSR이 더 빠르다. CSR은 모든 구성 코드를 다 받아온 상태이고, SSR은 첫 페이지 로딩 과정을 정확히 다시 실행하기 때문에 CSR이 더 빠르다.

2. SEO 대응

- 검색 엔진은 자동화된 로봇인 크롤러로 웹사이트들을 읽는데, CSR은 자바스크립트를 실행시켜 동적으로 컨텐츠가 생성되기 때문에 자바스크립트가 실행되어야 메타데이터가 바뀌게 된다. SSR은 애초에 서버 사이드에서 컴파일 되어 클라이언트로 넘어오기 때문에 크롤러에 대응하기 용이하다.

3. 서버 자원 사용

- SSR은 CSR에 비해 서버 요청량이 많다.

## 4. 👍 Hydrate

- hydrate가 나오게 된 환경

```
CSR은 초기 로딩 속도 저하, SEO 한계, 느린 인터넷 속도에선 빈 화면만 보게 되는 유저 경험의 약점이 존재한다.
SSR은 느린 페이지 전환과 서버 부하가 많다는 약점이 존재한다.

✨ 이러한 CSR과 SSR 한계점들을 개선하기 위해 SSR with Hydration 기법이 등장했다.
```

- hydrate를 이해하기 위한 React의 웹페이지 구성원리

```
React는 JS파일만을 이용해 웹페이지를 구성한다. 실제 html 코드는 안에 내용이 하나도 없는 상태
➡️ 그래서 CSR이 SEO에 적합하지 않은 이유기도 하다.

React에서는 가장 기본 HTML document 코드와 JS 파일들을 클라이언트로 모두 보내고, 클라이언트 단에서 js 코드들을 통해 웹 화면을 렌더링 하며 페이지를 그린다.

또한, 웹페이지 렌더링 후에도 페이지 내에서 동작하는 모든 이벤트 또한 js로 인해 일어나게 된다.

즉, 자바스크립트 코드에서 모든 화면을 렌더링 후 HTML DOM 요소 중 root라는 아이디를 가진 element를 찾아서 하위로 주입하게 된다.
```

- hydrate를 이해하기 위한 Next.js의 웹페이지 구성원리

```
Next.js는 클라이언트에게 웹 페이지를 보내기 전, Server side 단에서 먼저 정적 페이지를 렌더링 한다(pre-rendering). 이렇게 생성된 HTML document를 클라이언트에게 보내고 나서, 바로 리액트가 번들링 된 자바스크립트 코드들을 클라이언트에게 전송한다.

이 때 맨 처음 응답 받는 요소는 document Type의 파일이고, 이후 React 코드들이 렌더링 된 js 파일들이 Chunk 단위로 다운로드 된다.

🌟 그리고 이 자바스크립트 코드들이 이전에 보내진 HTML DOM요소 위에서 한 번 더 렌더링을 하며 각자 자기 자리를 찾아가 매칭이 된다.
```

- hydrate 정의 (요약)

```
Next.js의 웹페이지 구성원리에서 보면, 클라이언트 단이 서버 단에게 받은 DOM은 동적인 이벤트가 하나도 없는 메마른 상태일 것이고 이 메마른 뼈대에 수분을 보충한다는 게 hydrate를 말하는 것이다.

즉, Hydrate는 Server Side 단에서 렌더링 된 정적 페이지와 번들링된 js파일을 클라이언트에게 보낸 뒤 클라이언트 단에서 html코드와 React인 js코드를 서로 매칭 시키는 과정을 말한다.

Hydrate는 ReactDOM의 함수이다.
Next.js에서는 SSR과 동시에 Hydration 과정을 내장하고 있어, 추가 작업 없이도 이를 손쉽게 적용할 수 있다.
```

- Next.js에서 구현하기

```
Next.js는 자바스크립트 기반의 리액트 SSR 프레임워크이다.

🖥️ ReactDOM.hydrate(element, container[, callback])

위 코드 처럼 ReactDOM.hydrate()를 호출하여 구현된다.
```
